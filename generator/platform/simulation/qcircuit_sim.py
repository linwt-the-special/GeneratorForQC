# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../src/platform/simulation/qcircuit_sim.ipynb.

# %% auto 0
__all__ = ['get_number_of_gate_params', 'gate_pool_to_gate_classes', 'instruction_name_to_gate', 'trace_density',
           'schmidt_rank_vector', 'rnd_circuit', 'optimize_circuit', 'plot_svr_stat']

# %% ../../../src/platform/simulation/qcircuit_sim.ipynb 2
from ...imports import *
from ...config_loader import *
from typing import List

from QuICT.core import *
from QuICT.core.gate import *
from QuICT.simulation.density_matrix import DensityMatrixSimulator

from qiskit import transpile

# %% ../../../src/platform/simulation/qcircuit_sim.ipynb 4
def get_number_of_gate_params(gate_cls):
    # return gate_cls.__init__.__code__.co_argcount - len(gate_cls.__init__.__defaults__) - 1 
    return gate_cls.params

# %% ../../../src/platform/simulation/qcircuit_sim.ipynb 5
def gate_pool_to_gate_classes(gate_pool: list[BasicGate]): 
    """Creates a vocabulary from a gate pool."""
    classes = {}
    
    for i,cls in enumerate(gate_pool):
        num_of_paramters = get_number_of_gate_params(cls)
        name = cls(*[0]*num_of_paramters).type.name
        classes[name] = (i+1)
        
    return classes

# %% ../../../src/platform/simulation/qcircuit_sim.ipynb 6
def instruction_name_to_gate(name: str) -> BasicGate:
    gate = gate_builder(gate_type=GateType[name])
    
    return gate

# %% ../../../src/platform/simulation/qcircuit_sim.ipynb 7
def trace_density(rho: np.ndarray, qindex: List[int]) -> np.ndarray:
    """ Output partial trace of the density matrix on th given qubits

    Args:
        rho (ndarray): Input density matrix.
        qindex (List[int]): A list of integers indicating the qubits to be traced.

    Returns: the partially traced density matrix.
    """
    if len(qindex) == 0:
        return rho

    size_rho = int(np.ceil(np.log2(max(rho.shape))))

    # group into successive qubit blocks
    sorted_q = sorted(qindex)
    if sorted_q[-1] > size_rho:
        raise ValueError("Qubit index out of range.")
    tr_q_info = []

    i = 0
    while i < len(qindex):
        step = 0
        while i + step < len(qindex):
            if sorted_q[i] + step == sorted_q[i + step]:
                step += 1
            else:
                break
        tr_q_info.append([sorted_q[i], sorted_q[i + step - 1]])
        i = i + step

    tr_q_info = np.array(tr_q_info, dtype=int)

    # consecutive partial trace
    reduced_rho = rho
    while tr_q_info.size > 0:
        start, end = tr_q_info[0, :].tolist()
        axis1, axis2 = 0, 1
        ein_reshape_dim = []
        post_reshape_dim = 1

        cur_size = int(np.ceil(np.log2(max(reduced_rho.shape))))

        pre_dim_exp = start
        post_dim_exp = cur_size - end - 1

        if pre_dim_exp > 0:
            axis1 += 1
            axis2 += 2

            ein_reshape_dim.append(1 << pre_dim_exp)
            post_reshape_dim = post_reshape_dim * (1 << pre_dim_exp)

        ein_reshape_dim.append(1 << (end - start + 1))

        if post_dim_exp > 0:
            axis2 += 1

            ein_reshape_dim.append(1 << post_dim_exp)
            post_reshape_dim = post_reshape_dim * (1 << post_dim_exp)

        reduced_rho = reduced_rho.reshape(ein_reshape_dim * 2)
        reduced_rho = np.trace(reduced_rho, axis1=axis1, axis2=axis2)
        reduced_rho = reduced_rho.reshape((post_reshape_dim, post_reshape_dim))

        # update q_info indices
        tr_q_info = tr_q_info - (end - start + 1)
        # update for next partial trace qubit block
        tr_q_info = tr_q_info[1:]

    return reduced_rho

# %% ../../../src/platform/simulation/qcircuit_sim.ipynb 8
def schmidt_rank_vector(densityMatrix: np.array):   
    """Return the SRV of a `DensityMatrix`."""
    systems_cnt = int(np.log2(densityMatrix.shape[0]))  
    total_trace = set(range(systems_cnt))    
    rank_vector = []
    
    for i in range(systems_cnt): 
        trace = list(total_trace - {i})
        red_densityMatrix = trace_density(densityMatrix, trace)        
        # r = np.count_nonzero(np.linalg.eigvals(red_densityMatrix) > 1e-14) # was slower during testing   
        r = np.linalg.matrix_rank(red_densityMatrix, hermitian=True).item()       
        rank_vector.append(r)
    
    return rank_vector

# %% ../../../src/platform/simulation/qcircuit_sim.ipynb 9
def rnd_circuit(num_of_qubits, num_of_gates, gate_pool: list[BasicGate], rng):
    """Create a random circuit."""
    qc = Circuit(num_of_qubits)    
    gate_indices = rng.choice(len(gate_pool), num_of_gates)
    
    for gate_index in gate_indices:
        gate_class = gate_pool[gate_index]
        
        num_of_paramters = get_number_of_gate_params(gate_class)
        params           = rng.uniform(low=0, high=2*np.pi, size=num_of_paramters) if num_of_paramters > 0 else [] # random between 0 and 2pi
        
        gate = gate_class(*params)      
        act_qubits = rng.choice(num_of_qubits, gate.targets + gate.controls, replace=False) # order: (*act_qubits)=(*control_qubits, *target_qubits)   
        gate | qc([*act_qubits])
    
    return qc

# %% ../../../src/platform/simulation/qcircuit_sim.ipynb 10
def optimize_circuit(qc: Circuit, gate_pool: list[BasicGate], optimization_level=2):
    """Use qiskit.compiler.transpile to optimize a circuit.
       This might cause some problem???
    """
    basis_gates = gate_pool_to_gate_classes(gate_pool).keys()
    
    while optimization_level > 0:
        try:
            qc_opt = transpile(qc, optimization_level=optimization_level, basis_gates=basis_gates) #target=target
            print(type(qc_opt))
            return qc_opt
        except Exception as er: pass
  
        optimization_level -= 1

    return qc

# %% ../../../src/platform/simulation/qcircuit_sim.ipynb 13
def plot_svr_stat(num_of_qubits, min_gates, max_gates, gs, samples, sort=False, opt=True, rng=np.random.default_rng()):    
    svr_list = list()
    for i in range(samples):
        qc = rnd_circuit(num_of_qubits, rng.integers(min_gates, max_gates+1), gs, rng) 
        if opt: qc = optimize_circuit(qc, gs)
        simulator = DensityMatrixSimulator(
            device="CPU",
            precision="double"
        )
        result = simulator.run(qc)
        svr = schmidt_rank_vector(result)
        if sort: svr = sorted(svr)
        svr_list.append(svr)           
    df = pd.DataFrame(data={"svr":svr_list})   
    cnts = df['svr'].value_counts(normalize=True)
    for n,v in zip(cnts.index, cnts.values): print(f"{n}: {v*100:.1f}%")    
    df['svr'].value_counts().plot(kind='bar')   
